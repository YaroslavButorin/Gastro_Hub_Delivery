# Cервис доставки еды Gastro Hub Delivery
Во втором модуле вы помогали компании Gastro Hub оптимизировать бизнес-процессы — и прекрасно справились! Gastro Hub продолжает кормить людей невероятно вкусной едой, успешно расширяется и покоряет очередные высоты. Компания развивает новое направление — доставку еды из своих заведений Gastro Hub Delivery (GHD). А также планирует коллаборацию с другими ресторанами, барами, кофейнями и пиццериями, чтобы курьеры GHD доставляли блюда из этих заведений.
В последнее время бизнес развивается стремительно, поэтому нагрузка на базу данных существенно возросла, и встал вопрос об оптимизации. Пора снова помочь Gastro Hub!
В этом проекте описания таблиц и ERD не будет — вам предстоит самостоятельно исследовать базу данных.
Проект состоит из двух частей. В первой части обозначены проблемы, которые возникают при эксплуатации системы. Вам нужно исследовать таблицы БД и предложить решения этих проблем. Во второй части ваша задача — определить медленные запросы и оптимизировать их.

## Задание 1
Клиенты сервиса начали замечать, что после нажатия на кнопку Оформить заказ система на какое-то время подвисает. 
Вот команда для вставки данных в таблицу orders, которая хранит общую информацию о заказах:
```sql
INSERT INTO orders
    (order_id, order_dt, user_id, device_type, city_id, total_cost, discount, 
    final_cost)
SELECT MAX(order_id) + 1, current_timestamp, 
    '329551a1-215d-43e6-baee-322f2467272d', 
    'Mobile', 1, 1000.00, null, 1000.00
FROM orders;
```
Чтобы лучше понять, как ещё используется в запросах таблица orders, выполните запросы из этого файла:
orders_stat.sql
Не переживайте, если какой-то запрос ничего не вернул, — это нормально. Пустой результат — тоже результат.
Проанализируйте возможные причины медленной вставки новой строки в таблицу orders.

## Задание 2
Клиенты сервиса в свой день рождения получают скидку. Расчёт скидки и отправка клиентам промокодов происходит на стороне сервера приложения. Список клиентов возвращается из БД в приложение таким запросом:
```sql
SELECT user_id::text::uuid, first_name::text, last_name::text, 
    city_id::bigint, gender::text
FROM users
WHERE city_id::integer = 4
    AND date_part('day', to_date(birth_date::text, 'yyyy-mm-dd')) 
        = date_part('day', to_date('31-12-2023', 'dd-mm-yyyy'))
    AND date_part('month', to_date(birth_date::text, 'yyyy-mm-dd')) 
        = date_part('month', to_date('31-12-2023', 'dd-mm-yyyy'))
```
Каждый раз список именинников формируется и возвращается недостаточно быстро. Оптимизируйте этот процесс.

### Задание 3
Также пользователи жалуются, что оплата при оформлении заказа проходит долго.
Разработчик сервера приложения Матвей проанализировал ситуацию и заключил, что оплата «висит» из-за того, что выполнение процедуры add_payment требует довольно много времени по меркам БД. 
Найдите в базе данных эту процедуру и подумайте, как можно ускорить её работу.

### Задание 4
Все действия пользователей в системе логируются и записываются в таблицу user_logs. Потом эти данные используются для анализа — как правило, анализируются данные за текущий квартал.
Время записи данных в эту таблицу сильно увеличилось, а это тормозит практически все действия пользователя. Подумайте, как можно ускорить запись. Вы можете сдать решение этой задачи без скрипта или — попробовать написать скрипт. Дерзайте!

### Задание 5
Маркетологи сервиса регулярно анализируют предпочтения различных возрастных групп. Для этого они формируют отчёт:
| day    | age    | spicy | fish | meat |
|--------|--------|-------|------|------|
|        | 0–20   |       |      |      |
|        | 20–30  |       |      |      |
|        | 30–40  |       |      |      |
|        | 40–100 |       |      |      |

В столбцах spicy, fish и meat отображается, какой % блюд, заказанных каждой категорией пользователей, содержал эти признаки.
В возрастных интервалах верхний предел входит в интервал, а нижний — нет.
Также по правилам построения отчётов в них не включается текущий день.
Администратор БД Серёжа заметил, что регулярные похожие запросы от разных маркетологов нагружают базу, и в результате увеличивается время работы приложения.
Подумайте с точки зрения производительности, как можно оптимально собирать и хранить данные для такого отчёта. В ответе на это задание не пишите причину — просто опишите ваш способ получения отчёта и добавьте соответствующий скрипт.

# Часть 2
## Вторая часть проекта — оптимизация запросов

Для выполнения заданий второй части разверните этот дамп базы данных:
`project_4_part2.sql`

В файле ниже — пользовательские скрипты, которые выполняются на базе данных. Выполните их на своём компьютере. Проверьте, что в вашей СУБД включён модуль `pg_stat_statements` — это обязательное условие. Вспомнить, как подключить модуль, можно в третьем уроке третьей темы.

Файл со скриптами:
`user_scripts_pr4.sql`

Ваша задача — найти пять самых медленных скриптов и оптимизировать их. Важно: при оптимизации в этой части проекта нельзя менять структуру БД.

В решении укажите способ, которым вы искали медленные запросы, а также для каждого из пяти запросов:
1. Составьте план запроса до оптимизации.
2. Укажите общее время выполнения скрипта до оптимизации (вы можете взять его из параметра `actual time` в плане запроса).
3. Отметьте узлы с высокой стоимостью и опишите, как их можно оптимизировать.
4. Напишите и вложите в решение все необходимые скрипты для оптимизации запроса.
5. Составьте план оптимизированного запроса.
6. Опишите, что изменилось в плане запроса после оптимизации.
7. Укажите общее время выполнения запроса после оптимизации.

План запроса вы составляете для себя. Опираясь на план, в решении опишите словами проблемные места и что стало лучше после изменений. Можно частично скопировать план, чтобы показать самые важные места. Не прикладывайте скриншоты плана запроса к решению — в таком формате ревьюер не сможет их прочитать.

В двух самых тяжёлых запросах можно сократить максимальную стоимость в несколько тысяч раз. В двух менее тяжёлых запросах можно увеличить производительность примерно в 100 и в 6 раз. В оставшемся запросе достаточно повысить производительность на 30%.

Вот примерный план, как можно работать с заданиями этой части.

Допустим, вы обнаружили в топе запрос:
```sql
SELECT chain
FROM partners
WHERE type = 'Салатный бар' 
    AND city_id = 5;
```
План запроса показал, что таблица partners последовательно сканируется по полям type и city_id.
Чтобы ускорить запрос, можно добавить индекс по этим полям:
```sql
CREATE INDEX type_city_id_partners_idx
ON partners(type, city_id);
```
После построения индекса в плане запроса последовательное сканирование поменялось на индексное — это снизило стоимость запроса.
